\section{Операционна семантика}\index{операционна семантика}

% Правилата за извод с предаване на параметрите по име, които означаваме като $\mu \Downarrow^P c$,
% са същите като тези с предаване на параметрите по стойност като 
% единствената разлика е, че вместо правилата $(4)_\Nat$ и $(4)_\bot$ имаме правилото $(4)$.

\marginpar{Това се нарича cost dynamics в \cite[стр. 58]{practical-foundations}.}
% В някои доказателства ще се наложи да правим индукция по дължината на извода $\to_P$.
% Затова дефинираме релацията $\mu \to^\ell_P \vv{a}$, която казва, че функционалният терм $\mu$
% се свежда до константата $\vv{a}$ след $\ell$ на брой прилагания на правилата на операционната семантика.
% Формално дефиницията е следната:


Дефинираме релация $\opsem{\ell}{P}$, която ни казва как един функционален терм $\mu$
се свежда до константата $\vv{a}$ след $\ell$ на брой стъпки следвайки следните правила:

\begin{framed}
% \begin{description}
% \item
%   За всяко $a \in \Nat$,
  \begin{figure}[H]
    \centering
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\scriptsize{(const)}}
      \UnaryInfC{$\vv{a} \opsem{0}{P} \vv{a}$}
    \end{prooftree}
%   \end{figure}
% \item
%   \begin{figure}[H]
    \begin{prooftree}
      \AxiomC{$\mu_1\opsem{\ell_1}{P} \vv{a}_1$}
      \AxiomC{$\mu_2\opsem{\ell_2}{P} \vv{a}_2$}
      \AxiomC{$a = \plus(a_1, a_2)$}
      \RightLabel{\scriptsize{(plus)}}
      \TrinaryInfC{$\mu_1 + \mu_2 \opsem{\ell_1+\ell_2+1}{P} \vv{a}$}
    \end{prooftree}
  % \end{figure}
  % \begin{figure}[H]
    \begin{prooftree}
      \AxiomC{$\mu_1\opsem{\ell_1}{P} \vv{a}_1$}
      \AxiomC{$\mu_2\opsem{\ell_2}{P} \vv{a}_2$}
      \AxiomC{$a = \minus(a_1, a_2)$}
      \RightLabel{\scriptsize{(minus)}}
      \TrinaryInfC{$\mu_1 - \mu_2 \opsem{\ell_1+\ell_2+1}{P} \vv{a}$}
    \end{prooftree}
%   \end{figure}
% \item
%   \begin{figure}[H]
    \begin{prooftree}
      \AxiomC{$\mu_1\opsem{\ell_1}{P} \vv{a}_1$}
      \AxiomC{$\mu_2\opsem{\ell_2}{P} \vv{a}_2$}
      \AxiomC{$a = \eq(a_1, a_2)$}
      \RightLabel{\scriptsize{(eq)}}
      \TrinaryInfC{$\mu_1\ \vv{==}\ \mu_2 \opsem{\ell_1+\ell_2+1}{P} \vv{a}$}
    \end{prooftree}
%   \end{figure}
% \item
%   \begin{figure}[H]
    \begin{prooftree}
      \AxiomC{$\mu_0\opsem{\ell_0}{P} \vv{a}_0$}
      \AxiomC{$\mu_1 \opsem{\ell_1}{P} \vv{a}_1$}
      \AxiomC{$\vv{a}_0 \not\equiv \vv{0}$}
      \RightLabel{\scriptsize{(if$^+$)}}
      \TrinaryInfC{$\ifelse{\mu_0}{\mu_1}{\mu_2} \opsem{\ell_0+\ell_1+1}{P} \vv{a}_1$}
    \end{prooftree}
%   \end{figure}  
% \item
%   \begin{figure}[H]
    \begin{prooftree}
      \AxiomC{$\mu_0\opsem{\ell_0}{P} \vv{0}$}
      \AxiomC{$\mu_2 \opsem{\ell_2}{P} \vv{a}_2$}
      \RightLabel{\scriptsize{(if$_0$)}}
      \BinaryInfC{$\ifelse{\mu_0}{\mu_1}{\mu_2} \opsem{\ell_0+\ell_2+1}{P} \vv{a}_2$}
    \end{prooftree}
%   \end{figure}
% \item
%   \begin{figure}[H]
    \begin{prooftree}
      \AxiomC{$\tau_i[\vv{x}_1/\mu_1,\dots,\vv{x}_{m_i}/\mu_{m_i}] \opsem{\ell}{P} \vv{a}$}
      \RightLabel{\scriptsize{(cbn)}}
      \UnaryInfC{$\vv{f}_i(\mu_1,\dots,\mu_{m_i}) \opsem{\ell+1}{P} \vv{a}$}
    \end{prooftree}
    \caption{Правила на операционната семантика на \FUN}
    \end{figure}
% \end{description}
\end{framed}



\begin{remark}
  Защо нямаме следното правило?
  \begin{figure}[h!]
    \begin{prooftree}
      \AxiomC{$\mu_0\opsem{\ell_0}{P} \vv{a}_0$}
      \AxiomC{$\mu_1\opsem{\ell_1}{P} \vv{a}_1$}
      \AxiomC{$\mu_2 \opsem{\ell_2}{P} \vv{a}_2$}
      \AxiomC{$a = \texttt{if}(a_0,a_1,a_2)$}
      % \RightLabel{\scriptsize{(if$_0$)}}
      \QuaternaryInfC{$\ifelse{\mu_0}{\mu_1}{\mu_2} \opsem{\ell_0+\ell_1+\ell_2+1}{P} \vv{a}$}
    \end{prooftree}
  \end{figure}
\end{remark}

\begin{remark}
  Ако искахме да дефинираме операционна семантика с предаване на параметрите по стойност, то щяхме да заменим
  правилото (cbn) със следното правило:
  \begin{prooftree}
    \AxiomC{$\tau_i[\vv{x}_1/\vv{b}_1,\dots,\vv{x}_{m_i}/\vv{b}_{m_i}] \opsem{\ell_0}{P} \vv{a}$}
    \AxiomC{$\mu_1 \opsem{\ell_1}{P} \vv{b}_1$}
    \AxiomC{$\cdots$}
    \AxiomC{$\mu_{m_i} \opsem{\ell_{m_i}}{P} \vv{b}_{m_i}$}
    \LeftLabel{\scriptsize{($\ell = \sum_{k \leq m_i}\ell_k $)}}
    \RightLabel{\scriptsize{(cbv)}}
    \QuaternaryInfC{$\vv{f}_i(\mu_1,\dots,\mu_{m_i}) \opsem{\ell+1}{P} \vv{a}$}
  \end{prooftree}
\end{remark}

Ще пишем $\mu \opsem{}{P} \vv{a}$, ако съществува $\ell$, за което $\mu \opsem{\ell}{P} \vv{a}$.
Също така, понякога ще пишем $\mu \opsem{<\ell}{P} \vv{a}$, когато искаме да кажем, че
$\mu$ се свежда до $\vv{a}$ след прилагане на по-малко от $\ell$ на брой правила от операционната семантика.

\begin{lemma}
  \marginpar{Защо не можем да направим индукция по построението на термовете?}
  Докажете, че за всеки затворен терм $\mu$,
  ако $\mu \opsem{}{P} \vv{a}$ и $\mu \opsem{}{P} \vv{a}'$, то $\vv{a} \equiv \vv{a}'$.
\end{lemma}
\begin{hint}
  Индукция по дължината на изчислението.
\end{hint}

За фиксирана програма $\vv{P}$, нека за всеки {\em функционален} терм $\mu$ да дефинираме
\[\eval{\mu}\df
  \begin{cases}
    b, & \text{ ако }\mu \opsem{}{P} \vv{b}\\
    \bot, & \text{ ако }\mu \text{ няма извод до константа}.
\end{cases}\]

\begin{framed}
  Операционната семантика по име на рекурсивната програма $\vv{P}[\varsx,\varsf]$ представлява
  изображението 
  \[\O\val{\vv{P}} \in \Cont{\Nat^{m_1}_\bot}{\Nat_\bot},\] където
  \[\O\val{\vv{P}}(a_1,\dots,a_{m_1}) \df
    \begin{cases}
      \eval{\vv{f}_1(\vv{a}_1,\dots,\vv{a}_{m_1})}, & \text{ако }\bot \not\in\{a_1,\dots,a_{m_1}\}\\
      \bot, & \text{ако }\bot \in \{a_1,\dots,a_{m_1}\}
    \end{cases}\]
  за произволни $a_1,\dots,a_{m_1} \in \Nat_\bot$.
\end{framed}

\begin{remark}
  Всъщност ние все още няма как да знаем, че за всяка програма $\vv{P}$,
  $\O\val{\vv{P}}$ е непрекъснато изображение.
  Този факт може да се докаже директно, но вместо това, ние ще видим, че
  $\O\val{\vv{P}} = \D\val{\vv{P}}$ и оттам ще получим непрекъснатостта на $\O\val{\vv{P}}$,
  защото от дефиницията на $\D\val{\vv{P}}$ е ясно, че то е непрекъснато изображение.
\end{remark}

\begin{example}
  Нека за програмата \vv{P}:
  \begin{haskellcode}
    f(x,y) = if x == y then 0 else 1 + f(x,y+1)
  \end{haskellcode}
  да разгледаме няколко извода с правилата на операционната семантика по име.
\end{example}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../sep"
%%% End:
