\section{Синтаксис}
Ще разгледаме един много прост език за функционално програмиране.
\begin{itemize}
\item
  \index{константа}
  \marginpar{За разлика от \cite{ditchev-soskov}, ще подходим както в \cite{winskel} и няма да въвеждаме термове от тип $\BB$.}
  \marginpar{Константите не са числа! Константите са синтактични обекти, докато числата са семантични обекти. Обърнете внимание, че в езика имаме константи за всяко естествено число, но в езика нямаме константа за $\bot$. Това е една разлика с \texttt{хаскел}, където в езика има константа за $\bot$ и тя е означена с \texttt{undefined}.}
  константи $\vv{n}$, за всяко число $n \in \Nat$;
  \Stefan{Да ги нарека обектови константи. По тази логика, операциите стават функционални константи}
\item
  \index{променлива!обектова}
  \index{променлива!нулев тип}
  \marginpar{Удобно е в нашия език още на синтактично ниво да правим разлика между двата типа променливи, които имаме в езика.}
  изброимо много променливи от тип 0 (или обектови променливи) $\vv{x}, \vv{y}, \vv{z}, \dots$, евентуално с индекси;
\item
  \index{променлива!функционална}
  изброимо много променливи от тип 1 (или функционални променливи) $\vv{f},\vv{g},\vv{h},\dots$, евентуално с индекси. 
  Формално погледнато, трябва на всяка функционална променлива $\vv{f}$
  да съпоставим число - брой аргументи, които приема. Нека да означим с $\sharp\vv{f}$ броя аргументи на $\vv{f}$.
  Обикновено броят аргументи на $\vv{f}$ ще е ясен от контекста.
\item
  \index{терм}
  Термовете, които обикновено ще означаваме с $\tau$, в езика \FUN те се формират според следната абстрактна граматика:
  \marginpar{Тук $m = \sharp\vv{f}$}
  \marginpar{Граматиката е във форма на Бекус-Наур.}
  \[\tau ::= \vv{n} \mid \vv{x} \mid \tau_1 + \tau_2 \mid \tau_1 - \tau_2 \mid \tau_1\ \vv{==}\ \tau_2 \mid \ifelse{\tau_1}{\tau_2}{\tau_3} \mid \vv{f}(\tau_1,\dots,\tau_m).\]
\item
  Ще записваме $\tau[\vv{x}_1,\dots,\vv{x}_n,\vv{f}_1,\dots,\vv{f}_k]$, когато искаме да означим, че променливите
  на терма $\tau$ са {\em измежду} посочените.
\item
  Ще наричаме един терм {\bf функционален}, ако той не съдържа обектови променливи.
  Обикновено ще означаваме функционалните термове с $\mu$, а произволни термове с $\tau$.
\item
  Най-удобно е да си мислим за един терм като за дърво.
\item
  \marginpar{\cite[стр. 13]{winskel}.}
  Ще пишем $\tau_1 \equiv \tau_2$, ако термовете $\tau_1$ и $\tau_2$ представляват едни и същи дървета.
  Например, $2+3 = 3+2$, но $2+3 \not\equiv 3+2$. 
\item
  \marginpar{Тук нямаме усложнения с дефиницията на замяната, защото нямаме свързани променливи.}
  С $\tau\subst{x}{\mu}$ ще означаваме терма получен от $\tau$, в който всяко срещане на обектовата променлива $\vv{x}$
  е заменена с функционалния терм $\mu$. Можем да дадем формална дефиниция с индукция по построението на термовете:
  \begin{itemize}
  \item
    Ако $\tau \equiv \vv{n}$, то $\vv{n}[\vv{x}/\mu] \equiv \vv{n}$.
  \item
    Ако $\tau \equiv \vv{x}$, то $\vv{x}[\vv{x}/\mu] \equiv \mu$.
  \item
    Ако $\tau \equiv \vv{y}$ и $\vv{y} \not\equiv \vv{x}$, то $\vv{y}[\vv{x}/\mu] \equiv \vv{y}$.
  \item
    Ако $\tau \equiv \tau_1 + \tau_2$, то
    \[\tau[x/\mu] \equiv \tau_1[x/\mu] + \tau_2[x/\mu].\]
  \item
    Ако $\tau \equiv \tau_1 - \tau_2$, то
    \[\tau[x/\mu] \equiv \tau_1[x/\mu] - \tau_2[x/\mu].\]
  \item
    Ако $\tau \equiv \tau_1\ \vv{==}\ \tau_2$, то
    \[\tau[x/\mu] \equiv \tau_1[x/\mu]\ \vv{==}\ \tau_2[x/\mu].\]
  \item
    Ако $\tau \equiv \ifelse{\tau_1}{\tau_2}{\tau_3}$, то
    \[\tau[x/\mu] \equiv \ifelse{\tau_1[x/\mu]}{\tau_2[x/\mu]}{\tau_3[x/\mu]}.\]
  \item
    Ако $\tau \equiv \vv{f}(\tau_1,\dots,\tau_m)$, то
    \[\tau[x/\mu] \equiv \vv{f}(\tau_1[x/\mu], \dots, \tau_m[x/\mu]).\]
  \end{itemize}  
\end{itemize}

\marginpar{\cite[стр. 141]{winskel}}

\index{рекурсивна програма}
Една {\bf рекурсивна програма} $\vv{P}$ на езика \FUN има следния общ вид:
\marginpar{Една програма е просто текст със специален формат. Важният въпрос е каква функция (семантика) отговаря на този текст (синтаксис)}
\marginpar{Може да си мислите, че $\vv{f}_1$ е $\vv{main}$ функцията на нашата програма. Тук важното е, че в термовете $\tau_1,\dots,\tau_k$, които дефинират $\vv{f}_1,\dots,\vv{f}_k$ могат да участват функционални променливи само измежду $\vv{f}_1,\dots,\vv{f}_k$.}
\begin{align*}
  \vv{P} = 
  \begin{cases}
    & \vv{f}_1(\vv{x}_1,\dots,\vv{x}_{m_1}) = \tau_1[\vv{x}_1,\dots,\vv{x}_{m_1},\vv{f}_1,\dots,\vv{f}_k]\\
    & \vdots\\
    & \vv{f}_k(\vv{x}_1,\dots,\vv{x}_{m_k}) = \tau_k[\vv{x}_1,\dots,\vv{x}_{m_k},\vv{f}_1,\dots,\vv{f}_k]
  \end{cases}
\end{align*}

В такъв случай казваме, че термът $\tau_i$ задава {\em дефиницията} на фунционалната променлива $\vv{f}_i$.

\begin{example}
  \label{ex:minus}
  Да разгледаме програмата $\vv{P}$ на езика \FUN:
  \begin{haskellcode}
h(x) = f(x, 1)
f(x,y) = if x == y then 0 
           else f(x, y+1) + 1
  \end{haskellcode}
  Да положим
  \begin{align*}
    & \tau_1[\vv{x},\vv{h},\vv{f}] \dfff \vv{f}(\vv{x},\vv{1})\\
    & \tau_2[\vv{x},\vv{y},\vv{h},\vv{f}] \dfff \ifelse{\vv{x == y}}{\vv{0}}{\vv{f(x,y+1) + 1}}.
  \end{align*}
  Тогава програмата $\vv{P}$ приема следния вид:
  \begin{align*}
    & \vv{h}(\vv{x}) = \tau_1[\vv{x},\vv{h},\vv{f}]\\
    & \vv{f}(\vv{x},\vv{y}) = \tau_2[\vv{x},\vv{y},\vv{h},\vv{f}].
  \end{align*}
\end{example}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../sep"
%%% End:
