\section{Най-малко решение на система от уравнения}\index{система}



Нека $\A_1,\dots,\A_n$ са области на Скот 
и да разгледаме изображенията
\[f_i:\prod^n_{k=1}\A_k \to \A_i,\] за $i = 1,\dots,n$.
\index{решение на система}
Казваме, че $\bar{a} = \pair{a_1,\dots,a_n}$ е {\bf решение на системата}

\begin{align*}
  \bigstar = 
  \begin{cases}
    &x_1 = f_1(x_1,\dots,x_n)\\
    & \ \vdots\\
    &x_n = f_n(x_1,\dots,x_n),
  \end{cases}
\end{align*}

ако са в сила равенствата
\begin{SystemEq}
  a_1 & = & f_1(a_1,\dots,a_n)\\
  & \vdots & \\
  a_n & = & f_n(a_1,\dots,a_n).  
\end{SystemEq}

\index{система!най-малко решение}

Казваме, че $\bar{a}$ е {\bf най-малкото решение} на системата $\bigstar$, ако за всяко друго решение $\bar{b}$
е изпълнено, че $\bar{a} \sqsubseteq \bar{b}$.

\begin{framed}
\begin{theorem}
  \label{th:sep:min-solution-system}
  За произволни изображения $f_i \in \Cont{\prod^n_{k=1}\A_k}{\A_i}$, за $i = 1,\dots,n$, системата
  \begin{SystemEq}
    x_1 & = & f_1(x_1,\dots,x_n)\\
    & \vdots & \\
    x_n & = & f_n(x_1,\dots,x_n),    
  \end{SystemEq}
  притежава най-малко решение.
\end{theorem}
\end{framed}
\begin{proof}
  Първо да дефинираме изображението
  \[g \df f_1\times\dots\times f_n : \prod^n_{k=1}\A_k \to  \prod^n_{k=1}\A_k,\]
  като 
  \[g(\ov{a}) \df \pair{f_1(\ov{a}),\dots,f_n(\ov{a})},\]
  което е непрекъснато според \Problem{cartesian-product:continuous}.
  От \hyperref[th:knaster-tarski]{Теоремата на Клини} знаем, че $g$ притежава най-малка неподвижна точка
  $\bar{a} = \pair{a_1,\dots,a_n}$. Ще проверим, че $\ov{a}$ е най-малкото решение на системата.
  \begin{itemize}
  \item 
    Понеже $\ov{a}$ е неподвижна точка на $g$, то
    \begin{align*}
      g(a_1,\dots,a_n) & = \pair{f_1(\ov{a}),\dots,f_n(\ov{a})} & \comment{\text{от деф. на }g}\\
                       & = \pair{a_1,\dots,a_n} & \comment{\ov{a}\text{ е неподвижна точка}}.
    \end{align*}
    Оттук директно следва, че $f_i(\bar{a}) = a_i$, за $i = 1, \dots, n$, и следователно $\ov{a}$ е решение на системата.
  \item
    Нека $\ov{b} = \pair{b_1,\dots,b_n}$ е друго решение на системата, т.е. 
    $f_i(\ov{b}) = b_i$, за $i = 1, \dots, n$. Тогава 
    $g(\ov{b}) = \pair{f_1(\ov{b}),\dots,f_n(\ov{b})} = \ov{b}$.
    Следователно $\bar{b}$ е неподвижна точна на $g$.
    Понеже $\ov{a} = \lfp(g)$, то $\ov{a} \sqsubseteq \ov{b}$.
  \end{itemize}
  Така достигнахме до извода, че $\ov{a}$ е най-малкото решение на системата.
\end{proof}

\begin{remark}
  Да разгледаме изображенията $f\in\Cont{\A\times\B}{\A}$, $g \in \Cont{\B}{\B}$ и
  системата от две уравнения:
  \begin{SystemEq}
    f(x,y) & = & x\\
    g(y) & = & y.    
  \end{SystemEq}
  % \[\left|
  %     \begin{array}{lcl}

  %     \end{array}
  %   \right.\]
  % \begin{align*}
  %   \left|
  %   & f(x,y) = x\\
  %   & g(y) = y.
  %     \right.
  % \end{align*}
  За да можем директно да се позовем на \Th{sep:min-solution-system} и да твърдим, че тази система има най-малко решение,
  ние трябва да разгледаме следната модификация на системата:
  \begin{SystemEq}
    f(x,y)       & = & x\\
    \hat{g}(x,y) & = & y,    
  \end{SystemEq}
  където $\hat{g}(x,y) = g(y)$, т.е. добавяме един фиктивен аргумент, защото искаме всички изображения да имат равен брой аргументи.
\end{remark}


Ще завършим този раздел с две твърдения, които ще улеснят нашите разсъждения при 
решаването на задачи.

\begin{framed}
  \begin{proposition}\label{pr:system:independent}
    Да разгледаме две изображения
    \begin{align*}
      & f \in \Cont{\A\times\B}{\A}\\
      & g \in \Cont{\B}{\B},
    \end{align*}
    за които имаме системата от уравнения
    \begin{align*}
      \bigstar = 
      \begin{cases}
        & f(x,y) = x\\
        & g(y) = y.
      \end{cases}
    \end{align*}  
    Нека $b_0 = \lfp(g)$ и $a_0 = \lfp(\hat{f})$, където $\hat{f}(a) \df f(a,b_0)$.
    Тогава $\pair{a_0,b_0}$ е най-малкото решение на системата $\bigstar$.
  \end{proposition}
\end{framed}
\begin{proof}
  \begin{itemize}
  \item
    Първо, понеже $b_0 = \lfp(g)$, то очевидно $g(b_0) = b_0$.
    Освен това, $a_0 = \lfp(\hat{f})$, откъдето следва, че $a_0 = f(a_0,b_0)$.
    Ясно е, че $\pair{a_0,b_0}$ е решение на системата $\bigstar$.
  \item
    Сега нека $\pair{a,b}$ е произволно решение на системата $\bigstar$.
    Да видим, че $\pair{a_0,b_0} \sqsubseteq \pair{a,b}$.
    \begin{itemize}
    \item 
      Първо, ясно е, че $b = g(b)$. Понеже $b_0 = \lfp(g)$, то $b_0 \sqsubseteq b$.
    \item
      Второ, ясно е, че 
      \begin{align*}
        a & = f(a,b) & \comment{a \text{ е решение на }\bigstar}\\
          & \sqsupseteq f(a,b_0) & \comment{b \sqsupseteq b_0}\\
          & = \hat{f}(a) & \comment{\text{от деф.}}
      \end{align*}
      Получихме, че $a \in \texttt{Pref}(\hat{f})$.
      От \Prop{prefix-point} знаем, че 
      \[a_0 \df \lfp(\hat{f}) \sqsubseteq a.\]
    \end{itemize}
    Заключваваме, че $\pair{a_0,b_0} \sqsubseteq \pair{a,b}$.
  \end{itemize}
\end{proof}

Нещата започнаха да стават прекалено абстрактни, затова нека да видим един прост пример, който показва,
че всъщност горното твърдение е близо до нашата интуиция.
\Stefan{По-долу в примера трябва да се цитира горното твърдение по някакъв разбираем начин.}

\begin{example}
  Нека да разгледаме следната програма на езика \texttt{хаскел}:
\begin{haskellcode}
ghci> let g(x,y) = if x == 0 then 0 else g(x-1,y) + y
ghci> let f(x) = if x == 0 then 1 else g(x,f(x-1))
\end{haskellcode}
Лесно се съобразява, че всъщност
\[g(x,y) = x * y.\]
Това означава, че можем да пренапишем дефиницията на $f$ по следния начин:
\begin{haskellcode}
ghci> let f(x) = if x == 0 then 1 else x * f(x - 1)
\end{haskellcode}
Сега лесно се съобразява, че $f(x) = x!$, за $x \in \Nat$.
Да не забравяме, че в \texttt{хаскел} имаме и константатa {\texttt undefined}.
Това означава, че ако се ограничим до $\Nat_\bot$, то по горния начин сме дефинирали следните две функции:
\begin{align}
  \label{eq:4}
  f(x) = & 
  \begin{cases}
    x!,   & \text{ако }x \in \Nat\\
    \bot, & \text{ако }x = \bot
  \end{cases}
  \\
  \label{eq:5}
  g(x,y) = &
  \begin{cases}
    x\cdot y, & \text{ако }x,y \in \Nat\\
    \bot,     & \text{ако }\bot \in \{x,y\}.
  \end{cases}  
\end{align}

Ясно е, че тези функции са монотонни, а следователно и непрекъснати.
Целта на \Chapter{rec} е да формализираме разсъжданията, които направихме по-горе.
Ще видим, че на тази програма можем да съпоставим система от {\em непрекъснати} изображения.

\marginpar{$x + \bot \df \bot$}
\marginpar{В \Chapter{rec} ще видим, че на всяка програма съпоставяме система от {\em непрекъснати} изображения. В конкретния пример можем директно да докажем, че $\Gamma$ и $\Delta$ са непрекъснати изображения.}

\begin{align*}
  \Gamma(f,g)(x) =
  \begin{cases}
    1, & x = 0\\
    g(x, f(x-1)), & x > 0\\
    \bot, & x = \bot\\
  \end{cases}
  \\
  \Delta(g)(x,y) = 
  \begin{cases}
    0, & x = 0\\
    g(x-1,y) + y, & x > 0\\
    \bot, & x = \bot.
  \end{cases}
\end{align*}

Да видим как можем да дефинираме тези изображения на {\texttt haskell}
и как можем получим редицата от апроксимации на най-малките неподвижни точки по Теоремата на Клини.

\begin{haskellcode}
ghci> let gamma(f, g)(x) = if x == 0 then 1 else g(x, f(x - 1))
ghci> let delta(g)(x, y) = if x == 0 then 0 else g(x - 1, y) + y
-- Започваме да строим редицата от апроксимации по Теоремата на Клини
ghci> let g1 = delta( \(x,y) -> undefined )
ghci> let g2 = delta(g1)
ghci> let g3 = delta(g2)
ghci> g3(2,4)
8
ghci> g3(3,4)
*** Exception: Prelude.undefined
-- Можем да подходим и по-мързеливо, като направо дефинираме безкрайния
-- списък от тези апроксимации.
ghci> let approx = (\(x,y) -> undefined):[delta(g) | g <- approx]
ghci> let g9 = approx !! 9
ghci> g9(8,100)
800
ghci> g9(9,100)
*** Exception: Prelude.undefined
-- най-малката неподвижна точка на delta
ghci> let psi(x) = (approx !! (x+1))(x) 
\end{haskellcode}

Горният пример ни подсказва, че с индукция по $k$, можем да докажем, че 
ако имаме редицата
\begin{align*}
  & g_0 = \bm{\bot}^{(2)}\\
  & g_{k+1} = \Delta(g_k),
\end{align*}
то, за произволнен индекс $k$, имаме
\[g_k(x,y) =
\begin{cases}
  x \cdot y, & \text{ако }x < k\text{ и }y \in \Nat\\
  \bot, & \text{иначе}.
\end{cases}\]
Тогава с помощта на Теоремата на Клини можем да докажем, че
\[\lfp(\Delta)(x,y) =
\begin{cases}
  x \cdot y, & \text{ако }x,y\in\Nat\\
  \bot,      & \text{ако }\bot \in \{x,y\}.
\end{cases}\]

Нека сега да разгледаме изображението
\[\hat\Gamma(f)(x) \df \Gamma(f, \lfp(\Delta))(x) = 
\begin{cases}
  1,              & \text{ако }x = 0\\
  x \cdot f(x-1), & \text{ако }x > 0\\
  \bot,           & \text{ако }x = \bot.
\end{cases}\]

Нека отново да видим как можем да дефинираме това изображение на {\texttt haskell}
и как можем получим редицата от апроксимации на най-малките неподвижни точки по Теоремата на Клини.
\begin{haskellcode}
ghci> let gamma(f,g)(x) = if x == 0 then 1 else g(x,f(x-1))
ghci> let gamma'(f) = gamma(f, \(x, y) -> x * y)
ghci> :t gamma'
gamma' :: (a -> a) -> a -> a
ghci> let approx' = (\x -> undefined):[gamma'(f) | f <- approx']
ghci> let f9 = approx' !! 9
ghci> f9(8)
40320
ghci> f9(9)
*** Exception: Prelude.undefined 
ghci> let phi(x) = (approx' !! (x+1))(x)
ghci> phi(8)    -- phi е най-малката неподвижна точка на gamma'
40320           -- лесно се съобразява, че phi(x) == x!
\end{haskellcode}

Горният пример ни подсказва, че с индукция по $k$, можем да докажем,
че ако имаме редицата
\begin{align*}
  & f_0 = \bm{\bot}^{(1)}\\
  & f_{k+1} = \hat\Gamma(f_k),
\end{align*}
то, за произволен индекс $k$, имаме
\[f_k(x) =
\begin{cases}
  x!, & \text{ако }x < k\\
  \bot, & \text{иначе}.
\end{cases}\]

\noindent Отново по Теоремата на Клини, 
\[\lfp(\hat\Gamma)(x) =
\begin{cases}
  x!, & \text{ако }x \in \Nat\\
  \bot, & \text{ако }x = \bot.
\end{cases}\]
            
От \Prop{system:independent} знаем, че двойката $(\lfp(\hat\Gamma)),\lfp(\Delta))$ е най-малкото решение на системата,
което е точно двойката изображения $(f,g)$ с дефиниции (\ref{eq:4}) и (\ref{eq:5}).
\end{example}

\begin{framed}
  \begin{proposition}\label{pr:system:definition}
    Да разгледаме изображенията $f \in \Cont{\A}{\B}$ и $g \in \Cont{\A}{\A}$
    и системата от две уравнения:
    \begin{align*}
      \bigstar = 
      \begin{cases}
        & f(y) = x\\
        & g(y) = y.
      \end{cases}
    \end{align*}  
    Нека $a_0 = \lfp(g)$.
    Тогава най-малкото решение на системата $\bigstar$ е наредената двойка
    \[\pair{f(a_0), a_0}.\]
  \end{proposition}
\end{framed}
\begin{proof}
  \begin{itemize}
  \item 
    Лесно се съобразява, че $\pair{f(a_0), a_0}$ е решение на системата $\bigstar$.
  \item
    Нека $\pair{c,d}$ е решение на системата $\bigstar$.
    Тогава $g(d) = d$ и понеже $a_0 = \lfp(g)$, то $a_0 \sqsubseteq d$.
    Освен това, $c = f(d) \sqsupseteq f(a_0)$.
    Получихме, че $\pair{f(a_0), a_0} \sqsubseteq \pair{c,d}$.
  \end{itemize}
  Заключаваме, че $\pair{f(a_0), a_0}$ е най-малкото решение на системата $\bigstar$.
\end{proof}

\Stefan{Тук пак трябва да се обясни как горното твърдение се използва в долния пример.}

\begin{example}
Да разгледаме следната програма:
  \begin{haskellcode}
ghci> :{  -- използване на multiline дефиниции
ghci> let g(x, y, z) = if x == y + z then z 
ghci|                    else if z == x + 1 then 0 
ghci|                      else g(x, y, z + 1)
ghci| :}
ghci> let f(x, y) = g(x, y, 0)
  \end{haskellcode}

Лесно се съобразява, че 
\[g(x,y) = 
\begin{cases}
  x - y, & \text{ако }x \geq y\\
  0, & \text{ако }x < y.
\end{cases}\]

Тази функция ще я означаваме като $x \monus y$.
На горната програма можем да съпоставим системата от непрекъснати изображения:

\begin{align*}
  \Gamma(g)(x,y) & = g(x,y,0)\\
  \Delta(g)(x,y,z) & = \begin{cases}
    z, & \text{ако } x = y+z\\
    0, & \text{ако } z = x + 1\\
    g(x,y,z+1), & \text{ иначе и }x,y,z\in\Nat\\
    \bot, & \bot \in \{x,y,z\}.
  \end{cases}
\end{align*}


\begin{haskellcode}
ghci> :{  -- Multiline
ghci> let delta(g)(x, y, z) = if x == y + z then z 
ghci|                           else if z == x + 1 then 0 
ghci|                             else g(x, y, z + 1)
ghci| :}
ghci> :t delta
delta :: ((t, t, t) -> t) -> (t, t, t) -> t
ghci> let approx = (\(x,y,z) -> undefined):[delta(g) | g <- approx]
ghci> let g9 = approx !! 9
ghci> g9(20,11,1)  -- 20-11 \in [1, 10)
9
ghci> g9(20,1,11) -- 20-1 \in [11, 20)
19
ghci> g9(2,11,4)  -- 2+1 \not\in [4, 13)
*** Exception: Prelude.undefined
\end{haskellcode}

Горният пример ни подсказва, че с индукция по $k$, можем да докажем,
че ако имаме редицата
\begin{align*}
  & g_0 = \bm{\bot}^{(3)}\\
  & g_{k+1} = \Delta(g_k),
\end{align*}
то, за произволно $k$, имаме
\[g_k(x,y,z) =
\begin{cases}
  0,   & x + 1\in [z,z+k)\\
  x-y, & x \geq y\ \&\ x-y \in [z,z+k)\\
  \bot, & \text{иначе}.
\end{cases}\]
Тогава можем да приложим Теоремата на Клини и да докажем, че
\[\lfp(\Delta)(x,y,z)  =
\begin{cases}
  x \monus y, & z \leq x+1\\
  \bot, & z > x+1\text{ или } \bot \in \{x,y,z\}.
\end{cases}\]
Тогава от \Prop{system:definition} следва, че
\[\lfp(\Gamma)(x,y) = \lfp(\Delta)(x,y,0) =
\begin{cases}
  x \monus y, & x,y\in\Nat\\
  \bot, & \bot \in \{x,y\}.
\end{cases}\]

Съобразете, че $\lfp(\Gamma) = \bigsqcup_k f_k$,
където $f_k(x,y) = g_k(x,y,0)$.

\end{example}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../sep"
%%% End:
