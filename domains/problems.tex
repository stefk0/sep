\newpage

\section{Задачи}

\begin{problem}
  Нека $\A$ е област на Скот и нека $f \in \Cont{\A}{\A}$.
  Да разгледаме множеството $B = \{a \in \A \mid f(a) = f\}$.
  Докажете, че $\B = (B, \sqsubseteq, \lfp(f))$ е област на Скот.
\end{problem}




\subsection{Категория на Скот $\mathcal{S}$}


Категория представлява съвкупност от:
\begin{itemize}
\item
  Съвкупност от обекти $a,b,c,\dots$
\item
  Съвкупност от морфизми $f,g,h,\dots$.
\item
  Операции $dom$ и $cod$, за които
  $dom(f)$ и $cod(f)$ са обекти.
  Ще пишем $f:a\to b$ когато $dom(f) = a$ и $cod(f) = b$.
\item
  Имаме операция $\circ$ със свойството, че
  за всеки два морфизма от вида $f:a\to b$ и $g : b \to c$, то
  $g \circ f : a \to c$ също е морфизъм и също така
  \[h \circ (f \circ g) = (h \circ f) \circ g.\]
\item
  За всеки обект $a$ съществува морфизъм $id_a:a\to a$ със свойството, че
  за всеки морфизъм $f:a\to b$, то
  $id_a \circ f = f$ и $f \circ id_b = f$.
\end{itemize}


\begin{itemize}
\item 
  Обектите са всички области на Скот
\item
  Морфизмите са всички непрекъснати изображения между области на Скот
\end{itemize}


Функтор $\F : \mathcal{S} \to \mathcal{S}$ е изображение, за което са изпълнени условията:
\begin{itemize}
\item
  $g \in \Cont{\A}{\B}$, то $\F(g) \in \Cont{\F(\A)}{\F(\B)}$;
\item
  $\F(id_\A) = id_{\F(\A)}$;
\item
  $\F(h\circ g) = \F(h) \circ \F(g)$.
\end{itemize}



\begin{haskellcode}
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{haskellcode}

\begin{haskellcode}
data Maybe a = Nothing | Just a

instance Functor Maybe where
  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap f Nothing = Nothing
  fmap f (Just x) = Just (f x)
\end{haskellcode}


Например, $\texttt{List}$ е функтор, където за произволно $g \in \Cont{\A}{\B}$
\[\texttt{List}(g) \in \Cont{\texttt{List}(\A)}{\texttt{List}(\B)}\]
и
\[\texttt{List}(g) \df \texttt{map}(g).\]


\begin{haskellcode}
instance Functor [] where
  fmap = map
\end{haskellcode}


\begin{haskellcode}
data Tree a = Leaf a | Root a (Tree a) (Tree a)

instance Functor Tree where
  fmap g (Leaf x) = Leaf (g x)
  fmap g (Root x l r) = Root (g x) (fmap g l) (fmap g r)
\end{haskellcode}


Например, $\texttt{Arrow}_\B$ е функтор, където
$\texttt{Arrow}_\B(\A) = \Cont{\B}{\A}$ и за произволно $f \in \Cont{\A}{\C}$,
\[\texttt{Arrow}_\B(f) : \Cont{\B}{\A} \to \Cont{\B}{\C}\]
и 
\[\texttt{Arrow}_\B(f)(g) \df f \circ g.\]

\begin{haskellcode}
instance Functor ((->) r) where
  fmap :: (a->b) -> (a->r) -> (b->r)
  fmap = (.)
\end{haskellcode}



\subsubsection*{Апликативни функтори}



\begin{haskellcode}
class (Functor f) => Applicative f where
  pure :: a -> f a
  (<*>) :: f(a -> b) -> f a -> f b
\end{haskellcode}


\begin{haskellcode}
instance Applicative Maybe where

  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap _ Nothing = Nothing
  fmap f Just x = Just (f x)

  pure :: a -> Maybe a
  pure x = Just x

  (<*>) :: Maybe(a -> b) -> Maybe a -> Maybe b
  Nothing <*> _ = Nothing
  (Just f) <*> x = fmap f x
\end{haskellcode}

\begin{haskellcode}
instance Applicative [] where

  fmap :: (a->b) -> [a] -> [b]
  fmap f xs = [f x | x <- xs]
  -- fmap = map
  
  pure :: a -> [a]
  pure x = [x]

  <*> :: [a->b] -> [a] -> [b]
  fs <*> xs = [f x | f <- fs, x <- xs]
\end{haskellcode}


\begin{haskellcode}
instance Applicative ((->) r) where

  fmap :: (a -> b) -> (r -> a) -> (r -> b)
  fmap f g = g . f
  -- fmap = (.)

  pure :: a -> (r -> a)
  pure x = (\_ -> x)

  <*> :: (r -> (a -> b)) -> (r -> a) -> (r -> b)
  f <*> g = \x -> f x (g x)  
\end{haskellcode}

<\$> is the infix version of fmap

\begin{haskellcode}

ghci> map (+2) [1,2,3]
[3,4,5]
ghci> fmap (+2) [1,2,3]
[3,4,5]
ghci> (+2) <$> [1,2,3]
[3,4,5]

\end{haskellcode}



\begin{haskellcode}
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
\end{haskellcode}


\begin{haskellcode}
instance Monad [] where
  return :: a -> [a]
  return x = [x]

  (>>=) :: [a] -> (a -> [b]) -> [b]
  xs >>= f = concat (map f xs)
\end{haskellcode}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../sep"
%%% End:
