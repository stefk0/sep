\section{Най-малко решение на система от уравнения}

\begin{problem}
  % \label{pr:cartesian-continuous}
  Нека $f \in \Cont{\A}{\B}$ и $g \in \Cont{\A}{\C}$.
  Докажете, че $h \in \Cont{\A}{\B\times\C}$, където
  \[h(a) \dff \pair{f(a),g(a)}.\]
  В такъв случай ще означаваме $h = f \times g$.
\end{problem}
\begin{proof}
  Нека $(a_i)^{\infty}_{i=0}$ е верига в $\A$. Тогава:
  \begin{align*}
    h(\bigsqcup_i a_i) & = \pair{f(\bigsqcup_i a_i), g(\bigsqcup_i a_i)} & \comment{\text{от деф.}}\\
    & = \pair{\bigsqcup_i f(a_i), \bigsqcup_i g(a_i)} & \comment{\text{$f$ и $g$ са непр.}}\\
    & = \bigsqcup_i \pair{f(a_i),g(a_i)} & \comment{\text{от \Prop{cartesian}}}\\
    & = \bigsqcup_i h(a_i) & \comment{\text{от деф.}}
  \end{align*}
\end{proof}

Обърнете внимание на следващото твърдение, защото ще го използваме често по-късно.
То представлява обобщение на предишната задача и има сходно доказателство.
% Първо да въведем следното означение за произволно области на Скот $\B_1,\dots,\B_n$,
% \[\prod^n_{i=1}\B_i \dff \B_1\times \B_2 \times \cdots \B_n,\]
% което също е област на Скот, дефинирана в {\em Раздел \ref{subsect:domains:product}}.

\begin{prop}
  \label{pr:product-continuous}
  Нека $f_i \in \Cont{\A}{\B_i}$, за $i = 1,\dots,n$.
  \marginpar{\writedown Докажете сами!}
  Тогава
  \[g \in \Cont{\A}{\prod^n_{i=1}\B_i},\]
  където
  \[g(a) \dff \pair{f_1(a),f_2(a),\dots,f_n(a)}.\]
  В такъв случай ще означаваме $g = f_1\times f_2 \cdots \times f_n$.
\end{prop}
Нека $\A_1,\dots,\A_n$ са области на Скот 
и да разгледаме изображенията
\[f_i:\prod^n_{k=1}\A_k \to \A_i,\] за $i = 1,\dots,n$.
\index{решение на система}
Казваме, че $\bar{a} = \pair{a_1,\dots,a_n}$ е {\bf решение на системата}

\begin{align*}
  \bigstar = 
  \begin{cases}
    &f_1(x_1,\dots,x_n) = x_1\\
    & \ \vdots\\
    & f_n(x_1,\dots,x_n) = x_n,
  \end{cases}
\end{align*}

ако са в сила равенствата 
\begin{align*}
  & f_1(a_1,\dots,a_n) = a_1\\
  & \ \vdots\\
  & f_n(a_1,\dots,a_n) = a_n.
\end{align*}
\index{решение на система!най-малко}

Казваме, че $\bar{a}$ е {\bf най-малкото решение} на системата $\bigstar$, ако за всяко друго решение $\bar{b}$
е изпълнено, че $\bar{a} \sqsubseteq \bar{b}$.

\begin{framed}
\begin{thm}
  \label{th:sep:min-solution-system}
  За произволни изображения $f_i \in \Cont{\prod^n_{k=1}\A_k}{\A_i}$, за $i = 1,\dots,n$, системата
  \begin{align*}
    & f_1(x_1,\dots,x_n) = x_1\\
    & \vdots\\
    & f_n(x_1,\dots,x_n) = x_n,
  \end{align*} 
  притежава най-малко решение.
\end{thm}
\end{framed}
\begin{proof}
  Първо да дефинираме както в \Prop{product-continuous} непрекъснатото изображение 
  \[g \dff f_1\times\dots\times f_n : \prod^n_{k=1}\A_k \to  \prod^n_{k=1}\A_k,\]
  като 
  \[g(\bar{a}) \dff \pair{f_1(\bar{a}),\dots,f_n(\bar{a})}.\]
  От \hyperref[th:knaster-tarski]{Теоремата на Клини} знаем, че $g$ притежава най-малка неподвижна точка
  $\bar{a} = \pair{a_1,\dots,a_n}$. Ще проверим, че $\ov{a}$ е най-малкото решение на системата.
  \begin{itemize}
  \item 
    Понеже $\ov{a}$ е неподвижна точка на $g$, то
    \begin{align*}
      g(a_1,\dots,a_n) & = \pair{f_1(\ov{a}),\dots,f_n(\ov{a})} & \comment{\text{от деф. на }g}\\
                       & = \pair{a_1,\dots,a_n} & \comment{\ov{a}\text{ е неподвижна точка}}.
    \end{align*}
    Оттук директно следва, че $f_i(\bar{a}) = a_i$, за $i = 1, \dots, n$, и следователно $\ov{a}$ е решение на системата.
  \item
    Нека $\ov{b} = \pair{b_1,\dots,b_n}$ е друго решение на системата, т.е. 
    $f_i(\ov{b}) = b_i$, за $i = 1, \dots, n$. Тогава 
    $g(\ov{b}) = \pair{f_1(\ov{b}),\dots,f_n(\ov{b})} = \ov{b}$.
    Следователно $\bar{b}$ е неподвижна точна на $g$.
    Понеже $\ov{a} = \lfp(g)$, то $\ov{a} \sqsubseteq \ov{b}$.
  \end{itemize}
  Така достигнахме до извода, че $\ov{a}$ е най-малкото решение на системата.
\end{proof}

Ще завършим този раздел с две твърдения, които ще улеснят нашите разсъждения при 
решаването на задачи.

\begin{framed}
  \begin{prop}
    \label{pr:system:independent}
    Да разгледаме изображенията $f \in \Cont{\A\times\B}{\A}$ и $g \in \Cont{\B}{\B}$,
    за които имаме системата от уравнения
    \begin{align*}
      \bigstar = 
      \begin{cases}
        & f(x,y) = x\\
        & g(y) = y.
      \end{cases}
    \end{align*}  
    Нека $b_0 = \lfp(g)$ и $a_0 = \lfp(\hat{f})$, където $\hat{f}(a) \df f(a,b_0)$.
    Тогава $\pair{a_0,b_0}$ е най-малкото решение на системата $\bigstar$.
  \end{prop}
\end{framed}
\begin{proof}
  \begin{itemize}
  \item
    Първо, понеже $b_0 = \lfp(g)$, то очевидно $g(b_0) = b_0$.
    Освен това, $a_0 = \lfp(\hat{f})$, откъдето следва, че $a_0 = f(a_0,b_0)$.
    Ясно е, че $\pair{a_0,b_0}$ е решение на системата $\bigstar$.
  \item
    Сега нека $\pair{a,b}$ е произволно решение на системата $\bigstar$.
    Да видим, че $\pair{a_0,b_0} \sqsubseteq \pair{a,b}$.
    \begin{itemize}
    \item 
      Първо, ясно е, че $b = g(b)$. Понеже $b_0 = \lfp(g)$, то $b_0 \sqsubseteq b$.
    \item
      Второ, ясно е, че 
      \begin{align*}
        a & = f(a,b) & \comment{a \text{ е решение на }\bigstar}\\
          & \sqsupseteq f(a,b_0) & \comment{b \sqsupseteq b_0}\\
          & = \hat{f}(a) & \comment{\text{от деф.}}
      \end{align*}
      Получихме, че $a \in \texttt{Pref}(\hat{f})$.
      От \Prop{prefix-point} знаем, че 
      \[a_0 \dff \lfp(\hat{f}) \sqsubseteq a.\]
    \end{itemize}
    Заключваваме, че $\pair{a_0,b_0} \sqsubseteq \pair{a,b}$.
  \end{itemize}
\end{proof}

Нещата започнаха да стават прекалено абстрактни, затова нека да видим един прост пример, който показва,
че всъщност горното твърдение е близо до нашата интуиция.
\Stefan{По-долу в примера трябва да се цитира горното твърдение по някакъв разбираем начин.}

\begin{example}
  Нека да разгледаме следната програма на езика \texttt{haskell}:
\begin{haskellcode}
ghci> let g(x,y) = if x == 0 then 0 else g(x-1,y) + y
ghci> let f(x) = if x == 0 then 1 else g(x,f(x-1))
\end{haskellcode}
Лесно се съобразява, че всъщност
\[g(x,y) = x * y.\]
Това означава, че можем да пренапишем дефиницията на $f$ по следния начин:
\begin{haskellcode}
ghci> let f(x) = if x == 0 then 1 else x * f(x - 1)
\end{haskellcode}
Сега лесно се съобразява, че $f(x) = x!$, за $x \in \Nat$.
Да не забравяме, че в {\texttt haskell} имаме и константатa {\texttt undefined}.
Това означава, че ако се ограничим до $\Nat_\bot$, то по горния начин сме дефинирали следните две функции:
\begin{align}
  \label{eq:4}
  f(x) = & 
  \begin{cases}
    x!,   & \text{ако }x \in \Nat\\
    \bot, & \text{ако }x = \bot
  \end{cases}
  \\
  \label{eq:5}
  g(x,y) = &
  \begin{cases}
    x\cdot y, & \text{ако }x,y \in \Nat\\
    \bot,     & \text{ако }\bot \in \{x,y\}.
  \end{cases}  
\end{align}

Ясно е, че тези функции са точни, а следователно и непрекъснати.
Целта на \Chapter{rec} е да формализираме разсъжданията, които направихме по-горе.
Ще видим, че на тази програма можем да съпоставим система от {\em непрекъснати} изображения.

\marginpar{$x + \bot \dff \bot$}
\marginpar{В \Chapter{rec} ще видим, че на всяка програма съпоставяме система от {\em непрекъснати} изображения. В конкретния пример можем директно да докажем, че $\Gamma$ и $\Delta$ са непрекъснати изображения.}
\begin{align*}
  \Gamma(f,g)(x) =
  \begin{cases}
    1, & x = 0\\
    g(x, f(x-1)), & x > 0\\
    \bot, & x = \bot\\
  \end{cases}
  \\
  \Delta(g)(x,y) = 
  \begin{cases}
    0, & x = 0\\
    g(x-1,y) + y, & x > 0\\
    \bot, & x = \bot.
  \end{cases}
\end{align*}

Да видим как можем да дефинираме тези изображения на {\texttt haskell}
и как можем получим редицата от апроксимации на най-малките неподвижни точки по Теоремата на Клини.

\begin{haskellcode}
ghci> let gamma(f, g)(x) = if x == 0 then 1 else g(x, f(x - 1))
ghci> let delta(g)(x, y) = if x == 0 then 0 else g(x - 1, y) + y
-- Започваме да строим редицата от апроксимации по Теоремата на Клини
ghci> let omega2(x,y) = undefined
ghci> let g1 = delta(omega2)
ghci> let g2 = delta(g1)
ghci> let g3 = delta(g2)
ghci> g3(2,4)
8
ghci> g3(3,4)
*** Exception: Prelude.undefined
-- Можем да подходим и по-мързеливо, като направо дефинираме безкрайния
-- списък от тези апроксимации.
ghci> let approx = omega2:[delta(g) | g <- approx]
ghci> let g9 = approx !! 9
ghci> g9(8,100)
800
ghci> g9(9,100)
*** Exception: Prelude.undefined
-- най-малката неподвижна точка на delta
ghci> let psi(x) = (approx !! (x+1))(x) 
\end{haskellcode}

Горният пример ни подсказва, че с индукция по $k$, можем да докажем, че 
ако имаме редицата
\begin{align*}
  & g_0 = \Omega^{(2)}\\
  & g_{k+1} = \Delta(g_k),
\end{align*}
то, за произволно $k$, имаме
\[g_k(x,y) =
\begin{cases}
  x \cdot y, & \text{ако }x < k\text{ и }y \in \Nat\\
  \bot, & \text{иначе}.
\end{cases}\]
Тогава с помощта на Теоремата на Клини можем да докажем, че
\[\lfp(\Delta)(x,y) =
\begin{cases}
  x \cdot y, & \text{ако }x,y\in\Nat\\
  \bot,      & \text{ако }\bot \in \{x,y\}.
\end{cases}\]

Нека сега да разгледаме изображението
\[\hat\Gamma(f)(x) \dff \Gamma(f, \lfp(\Delta))(x) = 
\begin{cases}
  1,              & \text{ако }x = 0\\
  x \cdot f(x-1), & \text{ако }x > 0\\
  \bot,           & \text{ако }x = \bot.
\end{cases}\]

Нека отново да видим как можем да дефинираме това изображение на {\texttt haskell}
и как можем получим редицата от апроксимации на най-малките неподвижни точки по Теоремата на Клини.
\begin{haskellcode}
ghci> let gamma(f,g)(x) = if x == 0 then 1 else g(x,f(x-1))
ghci> let gamma'(f) = gamma(f, \(x, y) -> x * y)
ghci> :t gamma'
gamma' :: (a -> a) -> a -> a
ghci> let omega1(x) = undefined
ghci> let approx' = omega1:[gamma'(f) | f <- approx']
ghci> let f9 = approx' !! 9
ghci> f9(8)
40320
ghci> f9(9)
*** Exception: Prelude.undefined 
ghci> let phi(x) = (approx' !! (x+1))(x)
ghci> phi(8)    -- phi е най-малмата неподвижна точка на gamma'
40320           -- лесно се съобразява, че phi(x) == x!
\end{haskellcode}

Горният пример ни подсказва, че с индукция по $k$, можем да докажем,
че ако имаме редицата
\begin{align*}
  & f_0 = \Omega^{(1)}\\
  & f_{k+1} = \hat\Gamma(f_k),
\end{align*}
то, за произволно $k$, имаме
\[f_k(x) =
\begin{cases}
  x!, & x < k\\
  \bot, & \text{иначе}.
\end{cases}\]

\noindent Отново по Теоремата на Клини, 
\[\lfp(\hat\Gamma)(x) =
\begin{cases}
  x!, & x \in \Nat\\
  \bot, & x = \bot.
\end{cases}\]
            
От \Prop{system:independent} знаем, че двойката $(\lfp(\hat\Gamma)),\lfp(\Delta))$ е най-малкото решение на системата,
което е точно двойката изображения $(f,g)$ с дефиниции (\ref{eq:4}) и (\ref{eq:5}).
\end{example}

\begin{framed}
  \begin{prop}
    \label{pr:system:definition}
    Да разгледаме изображенията $f \in \Cont{\A}{\B}$ и $g \in \Cont{\A}{\A}$
    и системата:
    \begin{align*}
      \bigstar = 
      \begin{cases}
        & f(y) = x\\
        & g(y) = y.
      \end{cases}
    \end{align*}  
    Нека $a_0 = \lfp(g)$.
    Тогава най-малкото решение на системата $\bigstar$ е
    \[\pair{f(a_0), a_0}.\]
  \end{prop}
\end{framed}
\begin{proof}
  \begin{itemize}
  \item 
    Лесно се съобразява, че $\pair{f(a_0), a_0}$ е решение на системата $\bigstar$.
  \item
    Нека $\pair{c,d}$ е решение на системата $\bigstar$.
    Тогава $g(d) = d$ и понеже $a_0 = \lfp(g)$, то $a_0 \sqsubseteq d$.
    Освен това, $c = f(d) \sqsupseteq f(a_0)$.
    Получихме, че $\pair{f(a_0), a_0} \sqsubseteq \pair{c,d}$.
  \end{itemize}
  Заключаваме, че $\pair{f(a_0), a_0}$ е най-малкото решение на системата $\bigstar$.
\end{proof}

\Stefan{Тук пак трябва да се обясни как горното твърдение се използва в долния пример.}

\begin{example}
Да разгледаме следната програма:
  \begin{haskellcode}
ghci> :{  -- Multiline
ghci> let g(x, y, z) = if x == y + z then z 
ghci|                    else if z == x + 1 then 0 
ghci|                      else g(x, y, z + 1)
ghci| :}
ghci> let f(x, y) = g(x, y, 0)
  \end{haskellcode}

Лесно се съобразява, че 
\[g(x,y) = 
\begin{cases}
  x - y, & \text{ако }x \geq y\\
  0, & \text{ако }x < y.
\end{cases}\]

Тази функция ще я означаваме като $x \monus y$.
На горната програма можем да съпоставим системата от непрекъснати изображения:

\begin{align*}
  \Gamma(g)(x,y) & = g(x,y,0)\\
  \Delta(g)(x,y,z) & = \begin{cases}
    z, & \text{ако } x = y+z\\
    0, & \text{ако } z = x + 1\\
    g(x,y,z+1), & \text{ иначе и }x,y,z\in\Nat\\
    \bot, & \bot \in \{x,y,z\}.
  \end{cases}
\end{align*}


\begin{haskellcode}
ghci> :{  -- Multiline
ghci> let delta(g)(x, y, z) = if x == y + z then z 
ghci|                           else if z == x + 1 then 0 
ghci|                             else g(x, y, z + 1)
ghci| :}
ghci> :t delta
delta :: ((t, t, t) -> t) -> (t, t, t) -> t
ghci> let omega3(x,y,z) = undefined
ghci> let approx = omega3:[delta(g) | g <- approx]
ghci> let g9 = approx !! 9
ghci> g9(20,11,1)  -- 20-11 \in [1, 10)
9
ghci> g9(20,1,11) -- 20-1 \in [11, 20)
19
ghci> g9(2,11,4)  -- 2+1 \not\in [4, 13)
*** Exception: Prelude.undefined
\end{haskellcode}

Горният пример ни подсказва, че с индукция по $k$, можем да докажем,
че ако имаме редицата
\begin{align*}
  & g_0 = \Omega^{(3)}\\
  & g_{k+1} = \Gamma(g_k),
\end{align*}
то, за произволно $k$, имаме
\[g_k(x,y,z) =
\begin{cases}
  0,   & x + 1\in [z,z+k)\\
  x-y, & x \geq y\ \&\ x-y \in [z,z+k)\\
  \bot, & \text{иначе}.
\end{cases}\]
Тогава можем да приложим Теоремата на Клини и да докажем, че
\[\lfp(\Delta)(x,y,z)  =
\begin{cases}
  x \monus y, & z \leq x+1\\
  \bot, & z > x+1\text{ или } \bot \in \{x,y,z\}.
\end{cases}\]
Тогава от \Prop{system:definition} следва, че
\[\lfp(\Gamma)(x,y) = \lfp(\Delta)(x,y,0) =
\begin{cases}
  x \monus y, & x,y\in\Nat\\
  \bot, & \bot \in \{x,y\}.
\end{cases}\]

Съобразете, че $\lfp(\Gamma) = \bigsqcup_k f_k$,
където $f_k(x,y) = g_k(x,y,0)$.

\end{example}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../sep"
%%% End:
